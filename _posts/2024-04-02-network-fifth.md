---
title: Network fifth week
published: true
---

## <span style="color:#802548">_IP_</span>
- 인터넷에 연결되어 있는 모든 장치들(이른바 노드)를 식별할 수 고유 주소
- IP주소는 아래와 같이 두 종류가 있다.
  - IPv4
    - 최초의 인터넷 프로토콜
    - 주소는 32비트 방식으로, 8비트씩 4자리
    - 예로는 115.68.24.88와 같이 쓴다. 표기는 10진수를 활용
  - IPv6
    - IPv4 고갈에 대비한 두번째 프로토콜
    - 128 비트로 확장, 16비트씩 8자리
    - 예로는 3FFE:FFFF:7654:FEDA:1245:BA98:3210:4562와 같이 쓴다. 표기는 16진수를 활용
    - 4비트는 니블, 8비트는 옥텟이라고 부른다. 
- 한국에서는 IP주소를 KISA에서 관리한다. 
  - IP주소를 ISP가 부여받고, 사용자는 ISP에 가입헤 IP를 제공받아 인터넷을 사용한다.
  - 이렇게 발급받은 IP를 공인 IP라고 한다.
    - 공유기를 사용한 인터넷 접속 환경일 경우 공유기까지는 공인 IP 할당을 한다.
    - 공유기에 연결되어 있는 가정이나 회사의 각 네트워크 기기에는 사설 IP를 할당한다.
    - 사설 IP는 어떤 네트워크 안에서 내부적으로 사용되는 고유한 주소이다.


- linux에서 공인 IP와 사설IP를 모두 볼 때는 아래와 같은 명령어를 사용한다.
```sh
netstat -ano
```
- window에서 쓰는 ifconfig는 사설IP만을 보여준다.
- window에서 공인IP를 보려면 설정에 들어가서 봐야한다.


## <span style="color:#802548">_NAT와 Port Forwarding_</span>
- 사설IP를 해석해 인터넷에서 인식되는 공인 IP로 변환해주는 게 바로 NAT 기술이다.
  - 초기 IP 주소는 인터넷을 염두하지 않은 LAN에서만 쓰이는 사설 IP였다. 
  - 인터넷 등장 이후로 공인 IP가 생겼고, 공인 IP가 사설 IP에 해당하는 host에 패킷을 전달하게끔 하기 위해 NAT 기술이 발명됐다.
  - 사설 네트워크에 속한 여러개의 호스트가 하나의 공인 IP주소를 사용하여 인터넷에 접속하게끔 해준다.
    - IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록한다.
    - 즉 패킷을 변환시키고 그 과정에서 체크섬도 다시 계산하기 때문에 복잡성을 증가시킨다.
    - 네트워크 성능에 영향을 줄 수 있고, FTP, SIP 등의 프로토콜에서는 사용할 수 없다.
- 포트포워딩은 보통 NAT가 내부 ->외부에 쓰이는 것과 다르게 외부 -> 내부 데이터 이동에 도움을 주는 기술이다.
  - 1대 N NAT를 쓰면 외부에서 데이터가 들어왔을 때 가야할 host와 프로그램을 알지 못한다.
  - 따라서 특정 ip주소:포트 번호로 오는 통신 요청을 특정 다른 IP와 포트번호로 넘겨준다.
    - 사설 IP 주소 172.115.21.15인 디바이스의 1000번 포트에서 어떤 어플리케이션 프로세스가 가동중이라고 하자. 
    - 이 1000번 포트에 게이트웨이 라우터(115.94.13.51)의 2000번 포트로 포워딩되게 설정한다.
    - 그럼 앞으로 115.94.13.51:2000으로의 packet은 모두 해당 host의 program으로 전달된다.
    - 포트포워딩은 HTTP와 HTTPS에서 자주 쓰이는 기술이다.


<img src="/assets/private-public-nat.png" />


## <span style="color:#802548">_subnet과 subnetMask_</span>
- 초기 IP는 인터넷을 염두에 두지 않고 만들어졌다.
  - 따라서 네트워크 주소가 8비트, 호스트 주소가 24bit로 구성됐다.
  - 이는 LAN 네트워크는 256개인데, 호스트 수는 167만개임을 의미했다.
  - 보통의 LAN 네트워크는 호스트가 10만개를 넘지 못하니 엄청난 비효율이 양산되었다.
  - 그런데 인터넷이 등장하면서 256개의 네트워크 갯수로는 턱없이 부족하다는 걸 꺠닫게 된다.
- 그에 따라 classful IP가 등장했다.
  - 초기 IP완 다르게 네트워크 주소가 유동적이었다.
  - A는 xxxx.yyyy.zzzz.ddddd에서 첫번쨰까지 점까지 네트워크 주소다. 
  - B는 xxxx.yyyy.zzzz.ddddd에서 두번째까지 점까지 네트워크 주소다. 
  - C는 xxxx.yyyy.zzzz.ddddd에서 세번쨰까지 점까지 네트워크 주소다. 
- A는 대규모, B는 중규모, C는 소규모다.
  - A 클래스 사설
    - 10.0.0.0 ~ 10.255.255.255
  - A 클래스 공인
    - 1.0.0.0 ~ 9.255.255.255
    - 11.0.0.0 ~ 126.255.255.255
  - B 클래스 사설	
    - 172.16.255.255 ~ 172.31.255.255
  - B 클래스 공인
    - 128.0.0.0 ~ 172.15.255.255
    - 172.32.0.0 ~ 191.255.255.255
  - C 클래스 사설
    - 192.168.0.0 ~ 192.168.255.255
  - C 클래스 공인
    - 192.0.0.0 ~ 192.167.255.255
    - 192.169.0.0 ~ 223.255.255.255
- 그러나 classful IP에는 문제가 있었다. 
  - 현실적으로 기업이 B클래스만 선택했다. LAN과 host수가 적절하게 섞이는 비율이 B클래스 외엔 없었다.
  - 그런데 그와중에 인터넷이 폭발적으로 커가면서 낭비되는 주소가 너무 많았다.
  - 작은 기업이라 host가 256개 이상이어도 만개 이상은 필요하지 않은데, B클래스를 점유하니 그만큼 낭비가 되는 것이다.
- 그에 따라 CIDR(Classless Inter-Domain Routing)과 subnet 기술이 등장하게 된다.
  - 클래스를 나누지 않고, 네트워크 주소에 대한 범위만 정해 자유롭게 나누게 했다.
  - 즉 하나의 네트워크가 분할되어 나눠진 작은 네트워크가 서브넷이다.
  - 서브넷을 만들기위해 네트워크를 분할하는 것을 서브네팅(Subnetting)이라고 한다.
  - 서브넷 마스크는 ip주소에서 네트워크 ID와 호스트 ID로 구분하기 위한 목적으로 만들어 졌다.
  - 서브넷 마스크는 연속1 혹은 연속0으로 구성된다.
  - 서브네팅을 하는 주요 이유는 아래와 같다.
    - 네트워크 트래픽을 적절하게 나누어 혼잡을 방지하기 위한 목적
    - 상황별로 맞게 네트워크를 구성하여 유지보수를 용이하게 하기 위한 목적
- 서브넷에 따른 network 갯수와 host 갯수를 구하는 방법은 bit를 AND연산한다.
  - AND연산의 결과로 얻은 값이 곧 network이고 그 뒤부터는 host부다.
  - 학교에서 네트워크 한 block전체를 ISP에서 임대했다.
  - 따라서 현재 200.1.1.0이 전체 network 주소고, 200.1.1.255까지 사용가능하다. 
  - 이 상황에서 host 25개를 만족시키면서 IP를 최소로 만들자.
  - C class default subnetmask 기준(255.255.255.0) 비트 AND 연산을 한다고 가정한다.
    - 2개는 전체 네트워크와 브로드캐스트 주소라 제외한다.
    - 따라서 2의 n제곱 -2 > 25에서 최솟값은 n이 5일때다. 
    - 따라서 뒤 5자리는 host가 가져가고, 앞의 3자리는 subnetID가 가져간다.
    - 즉, 8개의 network(subnet)이 32개의 host를 받아갈 수 있다.
    - 200.1.1.1에서부터 200.1.1.254까지다. 200.1.1.0은 전체 network주소고, 200.1.1.255는 브로드캐스트 주소다.
  - 이번엔 default subnetmask가 아니라 255.255.255.224(11100000)로 바뀌었다.
    - 이 경우 비트 AND연산을 하게 되면 subnetID는 활용이 불가능하다. 네트워크 주소가 00000000인데 이를 11100000과 AND 연산하자.
    - 뒤 8bit AND 연산을 한 결과는 11100000이 아닌 00000000이게 된다. 따라서 subnetID부분은 모두 활용 불가능하다.
    - 따라서 host부만 남게되고, 200.1.1.1에서부터 200.1.1.30까지만 사용이 가능하다.
- 회사/기관은 보통 ISP에게 전체네트워크를 대여한다. C클래스 기준 193.128.166.0이란 전체 네트워크를 빌린다.
  - 193.128.166.0부터 193.128.166.255까지 전부 쓰는데, 그 중에 subnetmask로 잠글 IP를 선택한다.
  - 이떄 서브넷마스크 설정에 따른 가용가능한 IP를 생각하지 않으면, 사용가능한 IP가 삭제되는 결과를 초래한다.
    - 특히 회사가 이전을 하게되면서 다시 네트워크를 셋팅할 때, 서브넷마스크 이전 셋팅을 까먹는다면?
    - 기본 default subnetmask로 했다가 원래 git서버(gitlab)이나 DB서버 IP가 잠겨버린다면?
    - 그래서 원래 돌아가던 서비스가 먹통이 되면 아주 쫄깃한 경험을 할 것이다.



## <span style="color:#802548">_정적할당과 동적할당_</span>
- 정적 할당은 IP 주소를 수동으로 설정한다.
  - 정적 할당은 IP 주소를 고정적으로 사용하고 싶을 때 유용하다.
  - 웹 서버같이 도메인이 정해져 고정된 IP 주소로 접속해야 하는 곳에 정적 할당을 사용한다.
  - 운영에 쓰이는 서버들은 대부분 정적 할당으로 IP 주소를 지정한다.
    - 게이트웨이를 외부에 노출시킨다면 웹서버로의 요청은 포트포워딩을 통해 들어온다.
    - 게이트웨이를 외부에 노출시킨경우, 웹서버에는 공인IP가 아닌 사설IP를 부여하며, 서버의 사설 IP에 정적 IP를 할당한다.
    - 이는 WAS에도 마찬가지다. WAS를 내부 LAN에 숨기는 보안 효과도 있다.
- 동적 할당은 IP 주소를 자동으로 설정한다.
  - 일반 사용자들의 대부분은 동적할당 방식으로 ISP에게 공유기 혹은 벽랜 공인 IP를 지급받는다.
  - 동적 할당을 위해서는 DHCP라는 프로토콜을 사용한다. 이때 IP 주소는 DHCP 서버가 자동으로 정한다.
    - DHCP 서버는 네트워크에 연결된 장치들에게 IP 주소를 할당하고 관리하는 역할을 한다.
    - DHCP 서버는 일반적으로 공유기나 라우터에 내장되어 있다.
    - DHCP 서버는 네트워크에 접속하는 장치들과 4단계의 과정을 통해 통신한다.

```
Discover
장치가 부팅되면서 네트워크에 접속하면 IP 주소가 필요하다는 메시지를 전송합니다.
Offer
DHCP 서버가 장치에게 사용 가능한 IP 주소와 관련된 정보를 제안하는 메시지를 전송합니다.
Request
장치가 DHCP 서버가 제안한 IP 주소와 관련된 정보를 수락하겠다는 메시지를 전송합니다.
Acknowledge
DHCP 서버가 장치에게 IP 주소와 관련된 정보를 확정하고 확인하는 메시지를 전송합니다.
```

## <span style="color:#802548">_라우팅과 라우팅 프로토콜_</span>
- 라우팅은 패킷을 전송하기 위해 송신측에서 목적지까지의 경로를 설정하고 정해진 경로에 따라 패킷을 전달하는 과정을 말한다.
- 라우터에서는 아래 순서를 매번 거친다.
  - 랜테이블 검사를 한다. 이곳에서는 패킷의 목적지가 같은 네트워크에 있는지 아니면 다른 네트워크에 있는지를 확인한다.
    - 랜테이블은 라우터에 연결되어 있는 랜 세그먼트 내 장치의 주소를 관리하고 있으며 필터링작업에 사용된다.
  - 네트워크테이블을 검사하여 패킷을 전달할 네트워크 주소를 찾아낸다.
    - 네트워크상의 모든 라우터의 주소를 보관하며 패킷의 수신지 라우터를 식별하는데 사용된다.
  - 라우팅테이블을 검색하여 가장 적합한 경로를 찾아내서 패킷을 보낸다.
    - 각각의 라우터에 구축되어 있으며 각 경로에 대한 정보를 유지하고 있어서 다른 세그먼트로 전송 되는 패킷의 가장 효율적인 경로를 결정하는데 사용된다.
- 이 라우팅 테이블을 생성, 유지, 업데이트, 전달하는 프로토콜이 라우팅 프로토콜이다.
- 라우팅 프로토콜은 아래와 같이 나뉜다.
  - 정적라우팅(Static routing): 관리자에 의해 Routing Table이 유지/관리 되는 기법
    - 라우팅 테이블을 교환하지 않아 네트워크 대역폭을 절약할 수 있다. 
    - 또한 외부에 자신의 경로를 알리지 않기 때문에 보안에도 강하다. 
    - 하지만 경로에 문제가 생길 경우 대처하기 어렵다는 단점이 있다.
  - 동적라우팅(Dynamic routing): 라우팅 프로토콜에 의해 자동으로 라우팅 테이블을 구성하는 기법
    - 자동으로 경로가 결정되는 프로토콜이다. 라우터가 판단하여 가장 효율적인 방법으로 패킷을 전송시키는 방법이다.
    - 동적라우팅에 IGP와 EGP가 있다.
- EGP는 BGP이며, IGP는 거리벡터와 링크 스테이트 알고리즘을 쓴다.
  - 거리벡터는 RIP인데, 인접 router 간의 최적경로를 선택한다. 벨만-포드 알고리즘을 사용한다.
  - 링크 스테이트는 OSPF인데, 전체 네트워크를 보고 최적경로를 선택한다. 다익스트라 알고리즘을 사용한다.
- 각 라우팅 프로토콜을 더 자세하게 살펴보자.
  - RIP(Routing Information Protocol) 
    - 최소 Hop count를 파악하여 라우팅하는 프로토콜이다. 소규모 용도다. 4~6개까지 로드 밸런싱이 가능하다.
    - 최단거리 즉, Hop count가 적은 경로를 택하여 라우팅하는 프로토콜로 Routing Table에 인접 라우터 정보를 저장하여 경로를 결정한다.
    - 라우터의 메모리를 적게 사용하며, 30초마다 라우팅 정보를 업데이트 한다.
    - RIP는 단순 Hop을 count하여 경로를 결정하기 때문에 경로의 네트워크 속도는 판단하지 않는다. 비효율적인 경로로 패킷을 전달할 가능성이 있다.
  - OSPF(Open Shortest Path First)
    - 최단 경로 우선 프로토콜이다. 최저 COST(최저 시간) 경로를 최적 라우팅 경로로 결정한다.
    - SPF(최단거리우선 알고리즘)을 통해 라우팅 테이블을 생성한다.
    - Area 개념을 사용하여 전체 네트워크를 작은 영역으로 나눠 효율적으로 관리한다.
    - RIP가 30초마다 업데이트 되어 정보를 전송시키는 반면, OSPF는 링크에 상태변화가 있을 시에 즉각적으로 Flooding을 해주어 컨버전스 타임이 매우 빠르다.
    - 관리자에 따라 각 링크는 처리량, 왕복시간, 신뢰성 등을 기반으로 가중치를 할당받을 수 있다.
  - BGP(Border Gateway Protocol)
    - 서로 다른 조직의 네트워크를 연결할 때 사용하는 라우팅 프로토콜이다. 대규모 용도다.
    - 경로벡터(Distance Vector) 방식의 라우팅 프로토콜로 다른 IGP보다 컨버전스는 느리지만 대용량의 라우팅 정보를 교환할 수 있다.
 
## <span style="color:#802548">_ICMP_</span>
- 데이터 전송 방법에 대한 정보를 제공하기 위해 핑 및 트레이스라우트에서 사용하는 메시지를 보내는 데 사용된다.
  - ICMP의 가장 큰 용도는 오류 보고다.
    - 패킷이 정상 도착하지 않을 시, ICMP 메시지를 발신자에게 전송한다.
    - ICMP 프로토콜이 보내는 에코 요청 및 에코 응답을 ping이라한다.
    - ping으로도 두 host간의 연결 여부를 test할 수 있다.
    - 하지만 ping으로는 ICMP 메시지가 보이지 않기 때문에 wireshark를 사용해 패킷을 캡쳐해야 볼 수 있다.
  - 다른 용도는 네트워크 성능 평가다.
    - 트레이스 라우트에 의해 파악한 정보로 경로 중 지연을 일으키는 장치를 파악할 수 있다.
```sh
traceroute google.com
```

- ICMP는 IP와 함께 network 계층에서 사용된다. port 정보와는 무관하다.
- ICMP를 통해 네트워크 공격도 가능하다.
  - ICMP 플러드 공격
    - ICMP 에코 요청 패킷을 모두 처리할 수 없도록 엄청나게 많은 핑을 보내고, 패킷은 각각 처리 및 응답이 필요하기 때문에 장치의 리소스가 고갈돼 서비스가 마비된다.
  - Ping of Death
    - 최대 허용 크기보다 큰 패킷을 전송하는데, 처음에는 세그먼트로 쪼개지니 용량제한이 걸리지 않는다.
    - 대상 컴퓨터에서 조각을 다시 조립하려고 하면 합계가 크기 제한을 초과하고 버퍼 오버플로가 발생한다.

## <span style="color:#802548">_출처_</span>
https://study-recording.tistory.com/m/7 - IP
https://better-together.tistory.com/124 - 공인IP
https://ko.wikipedia.org/wiki/IPv6 - IPv6
https://technerd.tistory.com/36 - 포트포워딩
https://yozm.wishket.com/magazine/detail/2108/ - 서브넷마스크
https://eveningdev.tistory.com/55 - 서브넷마스크 계산
https://velog.io/@yoonuk/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-IP%EA%B0%80-%ED%95%A0%EB%8B%B9%EB%90%98%EB%8A%94-%EB%B0%A9%EB%B2%95 - 동적할당
https://velog.io/@hidaehyunlee/IP-%EB%9D%BC%EC%9A%B0%ED%8C%85routing-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95 - 라우팅
https://mindstation.tistory.com/172 - 라우팅 알고리즘
https://www.fortinet.com/kr/resources/cyberglossary/internet-control-message-protocol-icmp - ICMP
https://coding-everyday.tistory.com/20 - wireshark ICMP 패킷 분석
https://middleware.tistory.com/entry/RIP%EC%99%80-OSPF - RIP와 OSPF 비교